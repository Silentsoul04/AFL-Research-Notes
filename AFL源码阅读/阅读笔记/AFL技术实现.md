# AFL技术实现细节

## 代码插桩

## seed变异
在程序中产生新的状态的突变测试用例被添加到输入队列中，并作为未来用来编译的种子。
这种方法可以逐步探索底的层数据格式。

### 策略

#### bitflip
对于原始的文件最初进行的就是bitflip，根据位数/步长进行变异，执行顺序：
* bitflip 1/1   每次翻转翻转操作1位，按照1位的步长从头开始
* bitflip 2/1   每次翻转翻转操作相邻的2位，按照1位的步长从头开始
* bitflip 4/1   每次翻转翻转操作相邻的4位，按照1位的步长从头开始
* bitflip 8/8   每次翻转翻转操作相邻的8位，按照8位的步长从头开始
* bitflip 16/8  每次翻转翻转操作相邻的16位，按照8位的步长从头开始
* bitflip 32/8  每次翻转翻转操作相邻的32位，按照8位的步长从头开始

AFL不会放过每一个获取文件信息的机会。
在进行bitflip 1/1时，如果连续多个位被翻转翻转操作后，程序的执行路径都未变化但与原始执行路径不一致，就会把原始的这一段连续bytes作为一个token
在进行bitflip 8/8时，将会创建effector map，即当对每个byte进行翻转翻转操作时，如果造成的执行路径与原始路径不一致，就将该byte在effector map中标记为1表明该byte为"metadata"而非"data",方便后续的变异过程跳过这些byte。
但需要注意，以下情况所有字符都可能出现变异：
1. dumb mode或者从fuzzer
2. 文件大小小于128bytes
3. 一个文件超过90%的bytes有效

#### arithmetic
- arith 8/8     每次对1字节进行加减运算，按照每1字节的步长从头开始
- arith 16/8    每次对2字节进行加减运算，按照每2字节的步长从头开始
- arith 32/8    每次对4字节进行加减运算，按照每4字节的步长从头开始
加减的范围可在config中进行预定义

#### interest
- interest 8/8，每次对1位进行替换，按照1位的步长从头开始
- interest 16/8，每次对2位进行替换，按照1位的步长从头开始
- interest 32/8，每次对4位进行替换，按照1位的步长从头开始
用于替换的”interesting values”，是AFL预设的一些比较特殊的值

#### dictionary
用户可以通过-x参数提交在词典文件中提供的tokens，如果没有则跳过相应的此阶段。
会顺序进行如下操作：
- user extras (over)，从头开始，将用户提供的tokens依次替换到原文件中

AFL会首先按照长度从小到大对用户的输入tokens进行排序，然后AFL会对tokens的数量进行检查，如果其大于预设MAX则会随机选取tokens。

- user extras (insert)，从头开始，将用户提供的tokens依次插入到原文件中


- auto extras (over)，从头开始，将自动检测的tokens依次替换到原文件中

#### havoc
对于非dumb mode的主fuzzer来说，完成了上述deterministic fuzzing后，便进入了充满随机性的这一阶段；对于dumb mode或者从fuzzer来说，则是直接从这一阶段开始。
- 随机选取某个bit进行翻转
- 随机选取某个byte，将其设置为随机的interesting value
- 随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value
- 随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value
- 随机选取某个byte，对其减去一个随机数
- 随机选取某个byte，对其加上一个随机数
- 随机选取某个word，并随机选取大、小端序，对其减去一个随机数
- 随机选取某个word，并随机选取大、小端序，对其加上一个随机数
- 随机选取某个dword，并随机选取大、小端序，对其减去一个随机数
- 随机选取某个dword，并随机选取大、小端序，对其加上一个随机数
- 随机选取某个byte，将其设置为随机数
- 随机删除一段bytes
- 随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原
- 中随机位置的内容，25%的概率是插入一段随机选取的数
- 随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换
- 原文中随机位置的内容，25%的概率是替换成一段随机选取的数
- 随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换
- 随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入

AFL会生成一个随机数，作为变异组合的数量，并根据这个数量，每次从上面那些方式中随机选取一些依次作用到seed上。

#### splice
将两个seed文件拼接得到新的文件，并对这个新文件继续执行havoc变异。

#### cycle
一个seed执行完上述的全部变异后，就会从文件队列获取下一个进行变异。当队列中的全部文件都变异测试完成后，就完成了一个"cycle"。


## Reference
[1] [Fuzz结果分析和代码覆盖率](https://www.freebuf.com/column/197672.html)